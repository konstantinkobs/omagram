<html>
	<head>
		<script
			defer
			src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
		></script>

		<title>Omagramm</title>

		<!-- Webapp Config -->
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<link rel="apple-touch-icon" href="./images/icon.png">
		<meta name="apple-mobile-web-app-title" content="Omagramm">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">

		<!-- Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Poppins:wght@200;400;600&display=swap"
			rel="stylesheet"
		/>

		<style>
			:root {
				--red: #b80a0a;
			}

			* {
				box-sizing: border-box;
				font-family: 'Poppins', sans-serif;
			}

			html {
				background-image: url(images/background.png);
				background-repeat: repeat;

				padding-bottom: 2rem;
			}

			.app {
				margin: 0 auto;
				width: 100%;
				max-width: 700px;
			}

			.titleImage {
				height: 4rem;
			}

			.title {
				text-align: center;
				margin: 0;
				font-size: 3rem;
			}

			header {
				display: flex;
				margin-bottom: 1rem;
			}

			.board_container {
				display: grid;
				grid-template-areas:
					'. colhints'
					'rowhints grid';
				grid-template-columns: auto 1fr;
			}

			.grid {
				grid-area: grid;

				aspect-ratio: 1 / 1;

				display: flex;
				flex-direction: column;
			}

			.row {
				display: flex;
				flex-grow: 1;
			}

			.cell {
				display: block;
				border: 1px solid black;
				flex-grow: 1;

				position: relative;
			}

			.cellIsBlack {
				background-color: #333;
				background-image: url(images/black.png);
				background-repeat: no-repeat;
				background-size: contain;
			}

			.cellIsWhite {
				background-color: #afafaf;
				background-image: url(images/white.png);
				background-repeat: no-repeat;
				background-size: contain;
			}

			.tools {
				text-align: center;
			}

			.toolContainer {
				display: inline-block;
			}

			.tool {
				display: inline-block;
				width: 5rem;
				height: 5rem;

				border: 5px solid #ffffff00;
				margin: 0 0.2rem;
				border-radius: 0.2rem;

				cursor: pointer;
			}

			.selectedTool {
				border: 5px solid var(--red);
				box-shadow: 0 0 0.7rem rgba(0, 0, 0, 0.2);
			}

			.colHints {
				display: inline-block;
				text-align: center;

				flex: 1 1 0;
				display: flex;
				flex-direction: column;
				justify-content: flex-end;
			}

			.rowHintsContainer {
				grid-area: rowhints;

				display: flex;
				flex-direction: column;
			}

			.colHintsContainer {
				grid-area: colhints;

				display: flex;
			}

			.rowHints {
				text-align: right;

				flex: 1 1 0;
				display: flex;
				justify-content: flex-end;
			}

			.rowHint {
				padding: 0px 0.5rem;

				background-color: #333;
				color: white;
				margin: 0.1rem 0.2rem 0.1rem 0;
				border-radius: 0.2rem;

				display: flex;
				align-items: center;
			}

			.colHint {
				padding: 0.5rem 0px;
				text-align: center;

				background-color: #333;
				color: white;
				margin: 0 0.1rem 0.2rem 0.1rem;
				border-radius: 0.2rem;
			}

			.grid {
				border: 1px solid black;
			}

			.levels {
				text-align: center;
				display: block;
			}

			.level {
				display: inline-block;
				padding: 1rem 0.5rem;
				background: #eeeeeeaa;
				cursor: pointer;
				border: 0.5rem solid #ffffff20;
			}

			.selectedLevel {
				border: 0.5rem solid var(--red);
				color: var(--red);
			}

			.lives {
				display: block;
				text-align: center;
				flex: 1;
			}

			.livesNumber {
				display: block;
				font-size: 3rem;
			}

			.livesNumber[data-lives="3"] {
				color: green;
			}

			.livesNumber[data-lives="2"] {
				color: orange;
			}

			.livesNumber[data-lives="1"] {
				color: var(--red);
				animation: pulsing 2s ease-in-out infinite;
			}

			.newGameButton {
				display: block;
				text-align: center;
				font-size: 3rem;
				cursor: pointer;
			}

			.dialog {
				text-align: center;
				text-wrap: balance;

				background: white;
				padding: 1rem 2rem;

				border-radius: 0.3rem;
				box-shadow: 0 0 5rem #000;
			}

			.dialogBackground {
				position: fixed;
				display: flex;
				align-items: center;
				justify-content: center;

				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: #000000aa;
			}

			.dialogBackgroundWin {
				background: linear-gradient(-45deg, #f0e54caa, #68c233aa, #2ec25baa, #238bd5aa);
				background-size: 400% 400%;
				animation: gradient 2s ease infinite;
				height: 100vh;
			}
			
			.newGameTextButton {
				background: #eee;
				cursor: pointer;
				display: inline-block;
				padding: 0.5rem 1rem;
			}
			
			.label {
				display: block;
				text-align: center;
				color: #555;
				font-size: 0.8rem;
				padding: 1rem 0 0.2rem 0;
			}

			@keyframes gradient {
				0% {
					background-position: 0% 50%;
				}
				50% {
					background-position: 100% 50%;
				}
				100% {
					background-position: 0% 50%;
				}
			}

			@keyframes pulsing {
				0% {
					transform: scale(100%);
				}
				50% {
					transform: scale(150%);
				}
				100% {
					transform: scale(100%);
				}
			}

			@media screen and (orientation:landscape) {
				.title {
					position: fixed;
					top: 0;
					left: 0;
					font-size: 2rem;

					padding: 0.5rem 1rem;
				}

				.titleImage {
					height: 2rem;
				}

				.app {
					max-width: 500px;
				}
			}
		</style>
	</head>
	<body>
		<div class="app" x-data="nonogram">
			<h1 class="title">
				<img class="titleImage" src="images/black.png" alt="Omagramm">
				Omagramm</h1>
			<header>
				<div class="levels">
					<span class="label">Level</span>
					<span
						class="level"
						:class="n == 4 ? 'selectedLevel' : ''"
						@click="n = 4"
						>Leicht</span
					>
					<span
						class="level"
						:class="n == 6 ? 'selectedLevel' : ''"
						@click="n = 6"
						>Mittel</span
					>
					<span
						class="level"
						:class="n == 8 ? 'selectedLevel' : ''"
						@click="n = 8"
						>Schwer</span
					>
				</div>

				<div class="lives">
					<span class="label">Leben</span>
					<span class="livesNumber" :data-lives="lives" x-text="lives"></span>
				</div>

				<div class="newGame">
					<span class="label">Neues Spiel</span>
					<span class="newGameButton" @click="newGame()">üöÄ</span>
				</div>
			</header>

			<div class="board_container">
				<div class="colHintsContainer">
					<template x-for="hint in hints.cols">
						<div class="colHints">
							<template x-for="h in hint">
								<div class="colHint" x-text="h.num"></div>
							</template>
						</div>
					</template>
				</div>

				<div class="rowHintsContainer">
					<template x-for="hint in hints.rows">
						<div class="rowHints">
							<template x-for="h in hint">
								<div class="rowHint" x-text="h.num"></div>
							</template>
						</div>
					</template>
				</div>

				<div class="grid">
					<template x-for="(row, ridx) in board">
						<div class="row">
							<template x-for="(cell, cidx) in row">
								<div
									@click="selectCell(ridx, cidx)"
									class="cell"
									:class="whatIsSelected(cell)"
								></div>
							</template>
						</div>
					</template>
				</div>
			</div>

			<div class="tools">
				<div class="toolContainer">
					<span class="label">
						Markieren
					</span>
					<span
						class="tool cellIsBlack"
						:class="tool == 'black' ? 'selectedTool' : ''"
						@click="tool = 'black'"
					>
					</span>
				</div>
				<div class="toolContainer">
					<span class="label">
						Ausschlie√üen
					</span>
					<span
						class="tool cellIsWhite"
						:class="tool == 'white' ? 'selectedTool' : ''"
						@click="tool = 'white'"
					>
					</span>
				</div>
			</div>

			<footer>
				<details>
					<summary>Spielanleitung</summary>
					<h1>Anleitung</h1>
					<p>
						Das Omagramm ist eigentlich ein Nonogramm.
						Es handelt sich hierbei um ein japanisches R√§tsel, bei dem du manche K√§stchen des Gitters markieren musst.
						Links und oberhalb des Gitters findest du Zahlen, die angeben, wie viele <b>aufeinanderfolgende</b> K√§stchen markiert werden m√ºssen.
					</p>
					<p>
						<b>Beispiel:</b> Steht eine "3" links von der ersten Zeile, m√ºssen drei aufeinanderfolgende K√§stchen in dieser Zeile markiert werden.
						Da das Spielfeld aber mehr als drei K√§stchen in einer Zeile hat, musst du dir mithilfe der anderen Zahlen und dem, was du bisher markiert hast, herleiten, welche drei K√§stchen markiert werden m√ºssen.
					</p>
					<p>
						Stehen mehrere Zahlen als Hinweise bei einer Spalte oder Zeile, handelt es sich um mehrere zusammenh√§ngende K√§stchenketten von oben nach unten bzw. links nach rechts (in der Reihenfolge).
						Beachte, dass diese Ketten mindestens durch ein freies bzw. ausgeschlossenes K√§stchen getrennt sein m√ºssen.
					</p>
					<p>
						<b>Beispiel:</b> Stehen in einer Spalte eine "1" und dann eine "2" untereinander, muss diese Spalte von oben durch die Spalte gehend zuerst ein markiertes K√§stchen, dann mindestens ein ausgeschlossenes und dann zwei aufeinanderfolgende markierte K√§stchen beinhalten.
					</p>
					<p>Viel Spa√ü beim Spielen!</p>
				</details>
			</footer>

			<template x-if="lives == 0">
				<div class="dialogBackground dialogBackgroundLose">
					<div class="dialog">
						Du hast leider verloren. Versuche es noch einmal!
						<br />
						<br />
	
						<div class="newGameTextButton" @click="newGame()">
							Neues Spiel üöÄ
						</div>
					</div>
				</div>
			</template>

			<template x-if="solved">
				<div class="dialogBackground dialogBackgroundWin">
					<div class="dialog">
						Juchu, du hast gewonnen!
						<br />
						<br />
						<div class="newGameTextButton" @click="newGame()">
							Neues Spiel üöÄ
						</div>
					</div>
				</div>
			</template>

			<template x-if="wrongMove">
				<div class="dialogBackground">
					<div class="dialog">
						Das war leider nicht richtig.
						Du hast ein K√§stchen <span x-text="tool == 'black' ? 'markiert' : 'ausgeschlossen'"></span>, obwohl es <span x-text="tool == 'black' ? 'ausgeschlossen' : 'markiert'"></span> h√§tte werden m√ºssen. üôÅ
						<br />
						Das K√§stchen wurde korrigiert, aber du verlierst ein Leben.
						<br />
						<br />
						<div class="newGameTextButton" @click="wrongMove=false">
							Okay, weiter geht's üí™
						</div>
					</div>
				</div>
			</template>

		<script>
			function generateBoard(n, probability) {
				const board = [];
				// Generate rows
				for (let i = 0; i < n; i++) {
					const row = [];
					// Generate cells
					for (let j = 0; j < n; j++) {
						// Generate a random number between 0 and 1
						const random = Math.random();

						// Assign a boolean value based on the probability
						const value = random < probability ? 'black' : 'white';

						row.push({
							solution: value,
							selected: false,
						});
					}
					board.push(row);
				}

				// TODO: Maybe check whether this board is uniquely solvable.

				return board;
			}

			function data() {
				return {
					n: 4,
					prob: 0.6,
					board: [],
					wrongMove: false,
					get hints() {
						// Column Hints
						const colHints = [];
						for (let col = 0; col < this.board.length; col++) {
							const cHints = [];
							let counter = 0;
							for (let row = 0; row < this.board.length; row++) {
								const cell = this.board[row][col];

								if (cell.solution == 'black') {
									counter += 1;
								} else if (
									cell.solution == 'white' &&
									counter != 0
								) {
									cHints.push({
										num: counter,
										solved: false,
									});
									counter = 0;
								}
							}
							if (counter != 0) {
								cHints.push({
									num: counter,
									solved: false,
								});
							}

							colHints.push(cHints);
						}

						// Row Hints
						const rowHints = [];
						for (let row = 0; row < this.board.length; row++) {
							const rHints = [];
							let counter = 0;
							for (let col = 0; col < this.board.length; col++) {
								const cell = this.board[row][col];

								if (cell.solution == 'black') {
									counter += 1;
								} else if (
									cell.solution == 'white' &&
									counter != 0
								) {
									rHints.push({
										num: counter,
										solved: false,
									});
									counter = 0;
								}
							}
							if (counter != 0) {
								rHints.push({
									num: counter,
									solved: false,
								});
							}

							rowHints.push(rHints);
						}

						return {
							rows: rowHints,
							cols: colHints,
						};
					},
					get solved() {
						for (let row = 0; row < this.board.length; row++) {
							for (let col = 0; col < this.board.length; col++) {
								const cell = this.board[row][col];
								// if only white cells remain, everything is fine
								if (
									!cell.selected &&
									cell.solution == 'black'
								) {
									return false;
								}
							}
						}
						return true;
					},
					lives: 3,

					tool: 'black',

					init() {
						this.board = generateBoard(this.n, this.prob);

						this.$watch('n', (value) => {
							this.newGame();
						});
					},

					selectCell(cidx, ridx) {
						const cell = this.board[cidx][ridx];

						if (cell.selected) {
							// the cell is already selected and thus, nothing should happen
							return;
						}

						cell.selected = true;
						this.board[cidx][ridx] = cell;

						if (cell.solution != this.tool) {
							this.lives -= 1;
							if(this.lives > 0) {
								this.wrongMove = true;
							}
						}

						// Checks the cols and rows of the selected cell and completes them if they are complete
						let colCorrect = true;
						for (let idx = 0; idx < this.n; idx++) {
							const c = this.board[cidx][idx];
							if (c.solution == "black" && !c.selected) {
								colCorrect = false;
								break;
							}
						}
						if (colCorrect) {
							for (let idx = 0; idx < this.n; idx++) {
								this.board[cidx][idx].selected = true;
							}
						}
						let rowCorrect = true;
						for (let idx = 0; idx < this.n; idx++) {
							const c = this.board[idx][ridx];
							if (c.solution == "black" && !c.selected) {
								rowCorrect = false;
								break;
							}
						}
						if (rowCorrect) {
							for (let idx = 0; idx < this.n; idx++) {
								this.board[idx][ridx].selected = true;
							}
						}


						if (this.solved) {
							// Complete the grid
							for (let row = 0; row < this.board.length; row++) {
								for (
									let col = 0;
									col < this.board.length;
									col++
								) {
									this.board[row][col].selected = true;
								}
							}
						}
					},
					whatIsSelected(cell) {
						if (cell.selected) {
							if (cell.solution == 'black') {
								return 'cellIsBlack';
							} else if (cell.solution == 'white') {
								return 'cellIsWhite';
							}
						} else {
							// Cell is not clicked
							return '';
						}
					},
					newGame() {
						this.lives = 3;
						this.board = generateBoard(this.n, this.prob);
					},
				};
			}

			document.addEventListener('alpine:init', () => {
				Alpine.data('nonogram', data);
			});
		</script>
	</body>
</html>
