<html>
	<head>
		<script
			defer
			src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
		></script>

		<title>Omagramm</title>

		<!-- Webapp Config -->
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<link rel="apple-touch-icon" href="./images/icon.png">
		<meta name="apple-mobile-web-app-title" content="Omagramm">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">

		<!-- Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Poppins:wght@200;400;600&display=swap"
			rel="stylesheet"
		/>

		<style>
			:root {
				--red: #b80a0a;
			}

			* {
				box-sizing: border-box;
				font-family: 'Poppins', sans-serif;
			}

			html {
				background-image: url(images/background.png);
				background-repeat: repeat;

				padding-bottom: 2rem;
			}

			.app {
				margin: 0 auto;
				width: 100%;
				max-width: 700px;
			}

			.titleImage {
				height: 4rem;
			}

			.title {
				text-align: center;
				margin: 0;
				font-size: 3rem;
			}

			header {
				display: flex;
				margin-bottom: 1rem;
			}

			.board_container {
				display: grid;
				grid-template-areas:
					'. colhints'
					'rowhints grid';
				grid-template-columns: auto 1fr;
			}

			.grid {
				grid-area: grid;

				aspect-ratio: 1 / 1;

				display: flex;
				flex-direction: column;
			}

			.row {
				display: flex;
				flex-grow: 1;
			}

			.cell {
				display: block;
				border: 1px solid black;
				flex-grow: 1;

				position: relative;
			}

			.cellIsBlack {
				background-color: #333;
				background-image: url(images/black.png);
				background-repeat: no-repeat;
				background-size: contain;
			}

			.cellIsWhite {
				background-color: #afafaf;
				background-image: url(images/white.png);
				background-repeat: no-repeat;
				background-size: contain;
			}

			.tools {
				text-align: center;
			}

			.toolContainer {
				display: inline-block;
			}

			.tool {
				display: inline-block;
				width: 5rem;
				height: 5rem;

				border: 5px solid #ffffff00;
				margin: 0 0.2rem;
				border-radius: 0.2rem;

				cursor: pointer;
			}

			.selectedTool {
				border: 5px solid var(--red);
				box-shadow: 0 0 0.7rem rgba(0, 0, 0, 0.2);
			}

			.colHints {
				display: inline-block;
				text-align: center;

				flex: 1 1 0;
				display: flex;
				flex-direction: column;
				justify-content: flex-end;
			}

			.rowHintsContainer {
				grid-area: rowhints;

				display: flex;
				flex-direction: column;
			}

			.colHintsContainer {
				grid-area: colhints;

				display: flex;
			}

			.rowHints {
				text-align: right;

				flex: 1 1 0;
				display: flex;
				justify-content: flex-end;
			}

			.rowHint {
				padding: 0px 0.5rem;

				background-color: #333;
				color: white;
				margin: 0.1rem 0.2rem 0.1rem 0;
				border-radius: 0.2rem;

				display: flex;
				align-items: center;
			}

			.colHint {
				padding: 0.5rem 0px;
				text-align: center;

				background-color: #333;
				color: white;
				margin: 0 0.1rem 0.2rem 0.1rem;
				border-radius: 0.2rem;
			}

			.grid {
				border: 1px solid black;
			}

			.levels {
				text-align: center;
				display: block;
			}

			.level {
				display: inline-block;
				padding: 1rem 0.5rem;
				background: #eeeeeeaa;
				cursor: pointer;
				border: 0.5rem solid #ffffff20;
			}

			.selectedLevel {
				border: 0.5rem solid var(--red);
				color: var(--red);
			}

			.lives {
				display: block;
				text-align: center;
				flex: 1;
			}

			.livesNumber {
				display: block;
				font-size: 3rem;
			}

			.livesNumber[data-lives="3"] {
				color: green;
			}

			.livesNumber[data-lives="2"] {
				color: orange;
			}

			.livesNumber[data-lives="1"] {
				color: var(--red);
				animation: pulsing 2s ease-in-out infinite;
			}

			.newGameButton {
				display: block;
				text-align: center;
				font-size: 3rem;
				cursor: pointer;
			}

			.dialog {
				text-align: center;
				text-wrap: balance;

				background: white;
				padding: 1rem 2rem;

				border-radius: 0.3rem;
				box-shadow: 0 0 5rem #000;
			}

			.dialogBackground {
				position: fixed;
				display: flex;
				align-items: center;
				justify-content: center;

				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: #000000aa;
			}

			.dialogBackgroundWin {
				background: linear-gradient(-45deg, #f0e54caa, #68c233aa, #2ec25baa, #238bd5aa);
				background-size: 400% 400%;
				animation: gradient 2s ease infinite;
				height: 100vh;
			}
			
			.newGameTextButton {
				background: #eee;
				cursor: pointer;
				display: inline-block;
				padding: 0.5rem 1rem;
			}
			
			.label {
				display: block;
				text-align: center;
				color: #555;
				font-size: 0.8rem;
				padding: 1rem 0 0.2rem 0;
			}

			@keyframes gradient {
				0% {
					background-position: 0% 50%;
				}
				50% {
					background-position: 100% 50%;
				}
				100% {
					background-position: 0% 50%;
				}
			}

			@keyframes pulsing {
				0% {
					transform: scale(100%);
				}
				50% {
					transform: scale(150%);
				}
				100% {
					transform: scale(100%);
				}
			}

			@media screen and (orientation:landscape) {
				.title {
					position: fixed;
					top: 0;
					left: 0;
					font-size: 2rem;

					padding: 0.5rem 1rem;
				}

				.titleImage {
					height: 2rem;
				}

				.app {
					max-width: 500px;
				}
			}
		</style>
	</head>
	<body>
		<div class="app" x-data="nonogram">
			<h1 class="title">
				<img class="titleImage" src="images/black.png" alt="Omagramm">
				Omagramm</h1>
			<header>
				<div class="levels">
					<span class="label">Level</span>
					<span
						class="level"
						:class="n == 4 ? 'selectedLevel' : ''"
						@click="n = 4"
						>Leicht</span
					>
					<span
						class="level"
						:class="n == 6 ? 'selectedLevel' : ''"
						@click="n = 6"
						>Mittel</span
					>
					<span
						class="level"
						:class="n == 8 ? 'selectedLevel' : ''"
						@click="n = 8"
						>Schwer</span
					>
				</div>

				<div class="lives">
					<span class="label">Leben</span>
					<span class="livesNumber" :data-lives="lives" x-text="lives"></span>
				</div>

				<div class="newGame">
					<span class="label">Neues Spiel</span>
					<span class="newGameButton" @click="newGame()">🚀</span>
				</div>
			</header>

			<div class="board_container">
				<div class="colHintsContainer">
					<template x-for="hint in hints.cols">
						<div class="colHints">
							<template x-for="h in hint">
								<div class="colHint" x-text="h.num"></div>
							</template>
						</div>
					</template>
				</div>

				<div class="rowHintsContainer">
					<template x-for="hint in hints.rows">
						<div class="rowHints">
							<template x-for="h in hint">
								<div class="rowHint" x-text="h.num"></div>
							</template>
						</div>
					</template>
				</div>

				<div class="grid">
					<template x-for="(row, ridx) in board">
						<div class="row">
							<template x-for="(cell, cidx) in row">
								<div
									@click="selectCell(ridx, cidx)"
									class="cell"
									:class="whatIsSelected(cell)"
								></div>
							</template>
						</div>
					</template>
				</div>
			</div>

			<div class="tools">
				<div class="toolContainer">
					<span class="label">
						Markieren
					</span>
					<span
						class="tool cellIsBlack"
						:class="tool == 'black' ? 'selectedTool' : ''"
						@click="tool = 'black'"
					>
					</span>
				</div>
				<div class="toolContainer">
					<span class="label">
						Ausschließen
					</span>
					<span
						class="tool cellIsWhite"
						:class="tool == 'white' ? 'selectedTool' : ''"
						@click="tool = 'white'"
					>
					</span>
				</div>
			</div>

			<footer>
				<details>
					<summary>Spielanleitung</summary>
					<h1>Anleitung</h1>
					<p>
						Das Omagramm ist eigentlich ein Nonogramm.
						Es handelt sich hierbei um ein japanisches Rätsel, bei dem du manche Kästchen des Gitters markieren musst.
						Links und oberhalb des Gitters findest du Zahlen, die angeben, wie viele <b>aufeinanderfolgende</b> Kästchen markiert werden müssen.
					</p>
					<p>
						<b>Beispiel:</b> Steht eine "3" links von der ersten Zeile, müssen drei aufeinanderfolgende Kästchen in dieser Zeile markiert werden.
						Da das Spielfeld aber mehr als drei Kästchen in einer Zeile hat, musst du dir mithilfe der anderen Zahlen und dem, was du bisher markiert hast, herleiten, welche drei Kästchen markiert werden müssen.
					</p>
					<p>
						Stehen mehrere Zahlen als Hinweise bei einer Spalte oder Zeile, handelt es sich um mehrere zusammenhängende Kästchenketten von oben nach unten bzw. links nach rechts (in der Reihenfolge).
						Beachte, dass diese Ketten mindestens durch ein freies bzw. ausgeschlossenes Kästchen getrennt sein müssen.
					</p>
					<p>
						<b>Beispiel:</b> Stehen in einer Spalte eine "1" und dann eine "2" untereinander, muss diese Spalte von oben durch die Spalte gehend zuerst ein markiertes Kästchen, dann mindestens ein ausgeschlossenes und dann zwei aufeinanderfolgende markierte Kästchen beinhalten.
					</p>
					<p>Viel Spaß beim Spielen!</p>
				</details>
			</footer>

			<template x-if="lives == 0">
				<div class="dialogBackground dialogBackgroundLose">
					<div class="dialog">
						Du hast leider verloren. Versuche es noch einmal!
						<br />
						<br />
	
						<div class="newGameTextButton" @click="newGame()">
							Neues Spiel 🚀
						</div>
					</div>
				</div>
			</template>

			<template x-if="solved">
				<div class="dialogBackground dialogBackgroundWin">
					<div class="dialog">
						Juchu, du hast gewonnen!
						<br />
						<br />
						<div class="newGameTextButton" @click="newGame()">
							Neues Spiel 🚀
						</div>
					</div>
				</div>
			</template>

			<template x-if="wrongMove">
				<div class="dialogBackground">
					<div class="dialog">
						Das war leider nicht richtig.
						Du hast ein Kästchen <span x-text="tool == 'black' ? 'markiert' : 'ausgeschlossen'"></span>, obwohl es <span x-text="tool == 'black' ? 'ausgeschlossen' : 'markiert'"></span> hätte werden müssen. 🙁
						<br />
						Das Kästchen wurde korrigiert, aber du verlierst ein Leben.
						<br />
						<br />
						<div class="newGameTextButton" @click="wrongMove=false">
							Okay, weiter geht's 💪
						</div>
					</div>
				</div>
			</template>

		<script>
			function generateBoard(n, probability) {
				const board = [];
				// Generate rows
				for (let i = 0; i < n; i++) {
					const row = [];
					// Generate cells
					for (let j = 0; j < n; j++) {
						// Generate a random number between 0 and 1
						const random = Math.random();

						// Assign a boolean value based on the probability
						const value = random < probability ? 'black' : 'white';

						row.push({
							solution: value,
							selected: false,
						});
					}
					board.push(row);
				}

				// TODO: Maybe check whether this board is uniquely solvable.

				return board;
			}

			function data() {
				return {
					n: 4,
					prob: 0.6,
					board: [],
					wrongMove: false,
					get hints() {
						// Column Hints
						const colHints = [];
						for (let col = 0; col < this.board.length; col++) {
							const cHints = [];
							let counter = 0;
							for (let row = 0; row < this.board.length; row++) {
								const cell = this.board[row][col];

								if (cell.solution == 'black') {
									counter += 1;
								} else if (
									cell.solution == 'white' &&
									counter != 0
								) {
									cHints.push({
										num: counter,
										solved: false,
									});
									counter = 0;
								}
							}
							if (counter != 0) {
								cHints.push({
									num: counter,
									solved: false,
								});
							}

							colHints.push(cHints);
						}

						// Row Hints
						const rowHints = [];
						for (let row = 0; row < this.board.length; row++) {
							const rHints = [];
							let counter = 0;
							for (let col = 0; col < this.board.length; col++) {
								const cell = this.board[row][col];

								if (cell.solution == 'black') {
									counter += 1;
								} else if (
									cell.solution == 'white' &&
									counter != 0
								) {
									rHints.push({
										num: counter,
										solved: false,
									});
									counter = 0;
								}
							}
							if (counter != 0) {
								rHints.push({
									num: counter,
									solved: false,
								});
							}

							rowHints.push(rHints);
						}

						return {
							rows: rowHints,
							cols: colHints,
						};
					},
					get solved() {
						for (let row = 0; row < this.board.length; row++) {
							for (let col = 0; col < this.board.length; col++) {
								const cell = this.board[row][col];
								// if only white cells remain, everything is fine
								if (
									!cell.selected &&
									cell.solution == 'black'
								) {
									return false;
								}
							}
						}
						return true;
					},
					lives: 3,

					tool: 'black',

					init() {
						this.board = generateBoard(this.n, this.prob);

						this.$watch('n', (value) => {
							this.newGame();
						});
					},

					selectCell(cidx, ridx) {
						const cell = this.board[cidx][ridx];

						if (cell.selected) {
							// the cell is already selected and thus, nothing should happen
							return;
						}

						cell.selected = true;
						this.board[cidx][ridx] = cell;

						if (cell.solution != this.tool) {
							this.lives -= 1;
							if(this.lives > 0) {
								this.wrongMove = true;
							}
						}

						// Checks the cols and rows of the selected cell and completes them if they are complete
						let colCorrect = true;
						for (let idx = 0; idx < this.n; idx++) {
							const c = this.board[cidx][idx];
							if (c.solution == "black" && !c.selected) {
								colCorrect = false;
								break;
							}
						}
						if (colCorrect) {
							for (let idx = 0; idx < this.n; idx++) {
								this.board[cidx][idx].selected = true;
							}
						}
						let rowCorrect = true;
						for (let idx = 0; idx < this.n; idx++) {
							const c = this.board[idx][ridx];
							if (c.solution == "black" && !c.selected) {
								rowCorrect = false;
								break;
							}
						}
						if (rowCorrect) {
							for (let idx = 0; idx < this.n; idx++) {
								this.board[idx][ridx].selected = true;
							}
						}


						if (this.solved) {
							// Complete the grid
							for (let row = 0; row < this.board.length; row++) {
								for (
									let col = 0;
									col < this.board.length;
									col++
								) {
									this.board[row][col].selected = true;
								}
							}
						}
					},
					whatIsSelected(cell) {
						if (cell.selected) {
							if (cell.solution == 'black') {
								return 'cellIsBlack';
							} else if (cell.solution == 'white') {
								return 'cellIsWhite';
							}
						} else {
							// Cell is not clicked
							return '';
						}
					},
					newGame() {
						this.lives = 3;
						this.board = generateBoard(this.n, this.prob);
					},
				};
			}

			document.addEventListener('alpine:init', () => {
				Alpine.data('nonogram', data);
			});
		</script>
	</body>
</html>
