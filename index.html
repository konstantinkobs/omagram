<html>
	<head>
		<script
			defer
			src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
		></script>
		<script src="js/confetti.js"></script>

		<title>Omagramm</title>

		<!-- Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Poppins:wght@200;400;600&display=swap"
			rel="stylesheet"
		/>

		<style>
			:root {
				--red: #b80a0a;
			}

			* {
				box-sizing: border-box;
				font-family: 'Poppins', sans-serif;
			}

			html {
				background-image: url(images/background.png);
				background-repeat: repeat;
			}

			.app {
				margin: 0 auto;
				width: 100%;
				max-width: 500px;
			}

			.title {
				text-align: center;
				margin: 0;
				font-size: 3rem;
			}

			header {
				display: flex;
				margin-bottom: 1rem;
			}

			.board_container {
				display: grid;
				grid-template-areas:
					'. colhints'
					'rowhints grid';
				grid-template-columns: auto 1fr;
			}

			.grid {
				grid-area: grid;

				aspect-ratio: 1 / 1;

				display: flex;
				flex-direction: column;
			}

			.row {
				display: flex;
				flex-grow: 1;
			}

			.cell {
				display: block;
				border: 1px solid black;
				flex-grow: 1;

				position: relative;
			}

			.cellIsBlack {
				background-color: #333;
				background-image: url(images/black.png);
				background-repeat: no-repeat;
				background-size: contain;
			}

			.cellIsWhite {
				background-color: #afafaf;
				background-image: url(images/white.png);
				background-repeat: no-repeat;
				background-size: contain;
			}

			.tools {
				text-align: center;
			}

			.toolContainer {
				display: inline-block;
			}

			.tool {
				display: inline-block;
				width: 5rem;
				height: 5rem;

				border: 5px solid #ffffff00;
				margin: 0 0.2rem;
				border-radius: 0.2rem;

				cursor: pointer;
			}

			.selectedTool {
				border: 5px solid var(--red);
				box-shadow: 0 0 0.7rem rgba(0, 0, 0, 0.2);
			}

			.colHints {
				display: inline-block;
				text-align: center;

				flex: 1 1 0;
				display: flex;
				flex-direction: column;
				justify-content: flex-end;
			}

			.rowHintsContainer {
				grid-area: rowhints;

				display: flex;
				flex-direction: column;
			}

			.colHintsContainer {
				grid-area: colhints;

				display: flex;
			}

			.rowHints {
				text-align: right;

				flex: 1 1 0;
				display: flex;
				justify-content: flex-end;
			}

			.rowHint {
				padding: 0px 0.5rem;

				background-color: #333;
				color: white;
				margin: 0.1rem 0.2rem 0.1rem 0;
				border-radius: 0.2rem;

				display: flex;
				align-items: center;
			}

			.colHint {
				padding: 0.5rem 0px;
				text-align: center;

				background-color: #333;
				color: white;
				margin: 0 0.1rem 0.2rem 0.1rem;
				border-radius: 0.2rem;
			}

			.grid {
				border: 1px solid black;
			}

			.levels {
				text-align: center;
				display: block;
			}

			.level {
				display: inline-block;
				padding: 1rem 0.5rem;
				background: #eeeeeeaa;
				cursor: pointer;
				border: 0.5rem solid #ffffff20;
			}

			.selectedLevel {
				border: 0.5rem solid var(--red);
				color: var(--red);
			}

			.lives {
				display: block;
				text-align: center;
				flex: 1;
			}

			.livesNumber {
				display: block;
				font-size: 3rem;
				color: var(--red);
			}

			.newGameButton {
				display: block;
				text-align: center;
				font-size: 3rem;
				cursor: pointer;
			}

			.dialog {
				text-align: center;

				background: white;
				padding: 1rem 2rem;

				border-radius: 0.3rem;
				box-shadow: 0 0 5rem #000;
			}

			.dialogBackground {
				position: fixed;
				display: flex;
				align-items: center;
				justify-content: center;

				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: #000000aa;
			}

			.dialogBackgroundWin {
				background: linear-gradient(-45deg, #f0e54caa, #68c233aa, #2ec25baa, #238bd5aa);
				background-size: 400% 400%;
				animation: gradient 2s ease infinite;
				height: 100vh;
			}
			
			.newGameTextButton {
				background: #eee;
				cursor: pointer;
				display: inline-block;
				padding: 0.5rem 1rem;
			}
			
			.label {
				display: block;
				text-align: center;
				color: #555;
				font-size: 0.8rem;
				padding: 1rem 0 0.2rem 0;
			}

			@keyframes gradient {
				0% {
					background-position: 0% 50%;
				}
				50% {
					background-position: 100% 50%;
				}
				100% {
					background-position: 0% 50%;
				}
			}
		</style>
	</head>
	<body>
		<div class="app" x-data="nonogram">
			<h1 class="title">Omagramm</h1>
			<header>
				<div class="levels">
					<span class="label">Level</span>
					<span
						class="level"
						:class="n == 4 ? 'selectedLevel' : ''"
						@click="n = 4"
						>Leicht</span
					>
					<span
						class="level"
						:class="n == 6 ? 'selectedLevel' : ''"
						@click="n = 6"
						>Mittel</span
					>
					<span
						class="level"
						:class="n == 8 ? 'selectedLevel' : ''"
						@click="n = 8"
						>Schwer</span
					>
				</div>

				<div class="lives">
					<span class="label">Leben</span>
					<span class="livesNumber" x-text="lives"></span>
				</div>

				<div class="newGame">
					<span class="label">Neues Spiel</span>
					<span class="newGameButton" @click="newGame()">ðŸš€</span>
				</div>
			</header>

			<div class="board_container">
				<div class="colHintsContainer">
					<template x-for="hint in hints.cols">
						<div class="colHints">
							<template x-for="h in hint">
								<div class="colHint" x-text="h.num"></div>
							</template>
						</div>
					</template>
				</div>

				<div class="rowHintsContainer">
					<template x-for="hint in hints.rows">
						<div class="rowHints">
							<template x-for="h in hint">
								<div class="rowHint" x-text="h.num"></div>
							</template>
						</div>
					</template>
				</div>

				<div class="grid">
					<template x-for="(row, ridx) in board">
						<div class="row">
							<template x-for="(cell, cidx) in row">
								<div
									@click="selectCell(ridx, cidx)"
									class="cell"
									:class="whatIsSelected(cell)"
								></div>
							</template>
						</div>
					</template>
				</div>
			</div>

			<div class="tools">
				<div class="toolContainer">
					<span class="label">
						AuswÃ¤hlen
					</span>
					<span
						class="tool cellIsBlack"
						:class="tool == 'black' ? 'selectedTool' : ''"
						@click="tool = 'black'"
					>
					</span>
				</div>
				<div class="toolContainer">
					<span class="label">
						AusschlieÃŸen
					</span>
					<span
						class="tool cellIsWhite"
						:class="tool == 'white' ? 'selectedTool' : ''"
						@click="tool = 'white'"
					>
					</span>
				</div>
			</div>

			<template x-if="lives == 0">
				<div class="dialogBackground dialogBackgroundLose">
					<div class="dialog">
						Du hast leider verloren. Versuche es noch einmal!
						<br />
						<br />
	
						<div class="newGameTextButton" @click="newGame()">
							Neues Spiel ðŸš€
						</div>
					</div>
				</div>
			</template>

			<template x-if="solved">
				<div class="dialogBackground dialogBackgroundWin">
					<div class="dialog">
						Juchu, du hast gewonnen!
						<br />
						<br />
						<div class="newGameTextButton" @click="newGame()">
							Neues Spiel ðŸš€
						</div>
					</div>
				</div>
			</template>

		<script>
			function generateBoard(n, probability) {
				const board = [];
				// Generate rows
				for (let i = 0; i < n; i++) {
					const row = [];
					// Generate cells
					for (let j = 0; j < n; j++) {
						// Generate a random number between 0 and 1
						const random = Math.random();

						// Assign a boolean value based on the probability
						const value = random < probability ? 'black' : 'white';

						row.push({
							solution: value,
							selected: false,
						});
					}
					board.push(row);
				}

				// TODO: Maybe check whether this board is uniquely solvable.

				return board;
			}

			function data() {
				return {
					n: 4,
					prob: 0.6,
					board: [],
					get hints() {
						// Column Hints
						const colHints = [];
						for (let col = 0; col < this.board.length; col++) {
							const cHints = [];
							let counter = 0;
							for (let row = 0; row < this.board.length; row++) {
								const cell = this.board[row][col];

								if (cell.solution == 'black') {
									counter += 1;
								} else if (
									cell.solution == 'white' &&
									counter != 0
								) {
									cHints.push({
										num: counter,
										solved: false,
									});
									counter = 0;
								}
							}
							if (counter != 0) {
								cHints.push({
									num: counter,
									solved: false,
								});
							}

							colHints.push(cHints);
						}

						// Row Hints
						const rowHints = [];
						for (let row = 0; row < this.board.length; row++) {
							const rHints = [];
							let counter = 0;
							for (let col = 0; col < this.board.length; col++) {
								const cell = this.board[row][col];

								if (cell.solution == 'black') {
									counter += 1;
								} else if (
									cell.solution == 'white' &&
									counter != 0
								) {
									rHints.push({
										num: counter,
										solved: false,
									});
									counter = 0;
								}
							}
							if (counter != 0) {
								rHints.push({
									num: counter,
									solved: false,
								});
							}

							rowHints.push(rHints);
						}

						return {
							rows: rowHints,
							cols: colHints,
						};
					},
					get solved() {
						for (let row = 0; row < this.board.length; row++) {
							for (let col = 0; col < this.board.length; col++) {
								const cell = this.board[row][col];
								// if only white cells remain, everything is fine
								if (
									!cell.selected &&
									cell.solution == 'black'
								) {
									return false;
								}
							}
						}
						return true;
					},
					lives: 3,

					tool: 'black',

					init() {
						this.board = generateBoard(this.n, this.prob);

						this.$watch('n', (value) => {
							this.newGame();
						});
					},

					selectCell(cidx, ridx) {
						const cell = this.board[cidx][ridx];

						if (cell.selected) {
							// the cell is already selected and thus, nothing should happen
							return;
						}

						cell.selected = true;
						this.board[cidx][ridx] = cell;

						if (cell.solution != this.tool) {
							this.lives -= 1;
							// TODO: Give better feedback!
							console.log('Leider falsch!');
						}

						// Checks the cols and rows of the selected cell and completes them if they are complete
						let colCorrect = true;
						for (let idx = 0; idx < this.n; idx++) {
							const c = this.board[cidx][idx];
							if (c.solution == "black" && !c.selected) {
								colCorrect = false;
								break;
							}
						}
						if (colCorrect) {
							for (let idx = 0; idx < this.n; idx++) {
								this.board[cidx][idx].selected = true;
							}
						}
						let rowCorrect = true;
						for (let idx = 0; idx < this.n; idx++) {
							const c = this.board[idx][ridx];
							if (c.solution == "black" && !c.selected) {
								rowCorrect = false;
								break;
							}
						}
						if (rowCorrect) {
							for (let idx = 0; idx < this.n; idx++) {
								this.board[idx][ridx].selected = true;
							}
						}


						if (this.solved) {
							// Complete the grid
							for (let row = 0; row < this.board.length; row++) {
								for (
									let col = 0;
									col < this.board.length;
									col++
								) {
									this.board[row][col].selected = true;
								}
							}
						}
					},
					whatIsSelected(cell) {
						if (cell.selected) {
							if (cell.solution == 'black') {
								return 'cellIsBlack';
							} else if (cell.solution == 'white') {
								return 'cellIsWhite';
							}
						} else {
							// Cell is not clicked
							return '';
						}
					},
					newGame() {
						this.lives = 3;
						this.board = generateBoard(this.n, this.prob);
					},
				};
			}

			document.addEventListener('alpine:init', () => {
				Alpine.data('nonogram', data);
			});
		</script>
	</body>
</html>
